/**
* H:\Dropbox\Code\HackerRank\Challenges\Digit Recognition.cpp
* Created on: 2015-09-15-13.14.09, Tuesday
* Verdict: Not Solved
* Author: Enamul Hassan
**/

#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

#define SZ(a) ((int)a.size())
#define sz 200005
#define pb push_back
#define pp pop_back()
#define all(a) a.begin(),a.end()
#define ll long long
#define cntbit(mask) __builtin_popcount(mask)
#define unify(a) stable_sort(a.begin(),a.end());a.resize(distance(a.begin(),unique(all(a))));
#define fread freopen("tests/input11.txt","r",stdin)
#define fwrite freopen("output.txt","w",stdout)
#define inf (1e18)
#define chng(a,b) a^=b^=a^=b;
#define clr(abc,z) memset(abc,z,sizeof(abc))
#define PI acos(-1)
#define pi 3.14159265358979323846264338327950288419716939937510
#define fr(i,a,b) for(i=a;i<=b;i++)
#define cspf printf("Case %d:", cas++);
#define csco cout<<"Case "<<cas++<<":";
#define mod 1000000007
ll bigmod(ll sonkha,ll ghat,ll vag_const){ll vag_shesh=1;while(ghat>0){if(ghat%2==1){vag_shesh=(vag_shesh*sonkha)%vag_const;}ghat/=2;sonkha=(sonkha*sonkha)%vag_const;}return vag_shesh;}
ll inverse_mod(ll bivajok, ll vag_const){return bigmod(bivajok,vag_const-2, vag_const);}

using namespace std;

int n, m,nd,md;

bool grid[15][15], cur[15][15];

char chars[][15][15] = {
        {//0
"0000000000",
"0000110000",
"0001111000",
"0011001100",
"0110000110",
"0110000110",
"0110000110",
"0110000110",
"0011001100",
"0001111000",
"0000110000",
"0000000000"
    },
    {//1
"0000000000",
"0000110000",
"0001110000",
"0011110000",
"0000110000",
"0000110000",
"0000110000",
"0000110000",
"0000110000",
"0000110000",
"0011111100",
"0000000000"
    },
    {//2
"0000000000",
"0001111000",
"0011001100",
"0110000110",
"0000000110",
"0000001100",
"0000011000",
"0000110000",
"0001100000",
"0011000000",
"0111111110",
"0000000000"
    },
    {//3
"0000000000",
"0011111000",
"0110001100",
"0000000110",
"0000001100",
"0000111000",
"0000001100",
"0000000110",
"0000000110",
"0110001100",
"0011111000",
"0000000000"
    },
    {//4
"0000000000",
"0000001100",
"0000011100",
"0000111100",
"0001101100",
"0011001100",
"0110001100",
"0111111110",
"0000001100",
"0000001100",
"0000001100",
"0000000000"
    },
    {//5
"0000000000",
"0111111100",
"0110000000",
"0110000000",
"0110111000",
"0111001100",
"0000000110",
"0000000110",
"0110000110",
"0011001100",
"0001111000",
"0000000000"
    },
    {//6
"0000000000",
"0001111000",
"0011001100",
"0110000100",
"0110000000",
"0110111000",
"0111001100",
"0110000110",
"0110000110",
"0011001100",
"0001111000",
"0000000000"
    },
    {//7
"0000000000",
"0111111110",
"0000000110",
"0000000110",
"0000001100",
"0000011000",
"0000110000",
"0001100000",
"0011000000",
"0110000000",
"0110000000",
"0000000000"
    },
    {//8
"0000000000",
"0001111000",
"0011001100",
"0110000110",
"0011001100",
"0001111000",
"0011001100",
"0110000110",
"0110000110",
"0011001100",
"0001111000",
"0000000000"
    },
    {//9
"0000000000",
"0001111000",
"0011001100",
"0110000110",
"0110000110",
"0011001110",
"0001110110",
"0000000110",
"0010000110",
"0011001100",
"0001111000",
"0000000000"
    },
        {//0
"0000000000",
"0111111110",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0111111110",
"0000000000"
    },
    {//1
"0000100000",
"0001100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000",
"0000100000"
    },
    {//2
"0000000000",
"0111111110",
"0000000010",
"0000000010",
"0000000010",
"0111111110",
"0111111110",
"0100000000",
"0100000000",
"0100000000",
"0111111110",
"0000000000"
    },
    {//3
"0000000000",
"0111111110",
"0000000010",
"0000000010",
"0000000010",
"0001111110",
"0001111110",
"0000000010",
"0000000010",
"0000000010",
"0111111110",
"0000000000"
    },
    {//4
"0000000000",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0111111110",
"0111111110",
"0000000010",
"0000000010",
"0000000010",
"0000000010",
"0000000000"
    },
    {//5
"0000000000",
"0111111110",
"0100000000",
"0100000000",
"0100000000",
"0111111110",
"0111111110",
"0000000010",
"0000000010",
"0000000010",
"0111111110",
"0000000000"
    },
    {//6
"0000000000",
"0111111110",
"0100000000",
"0100000000",
"0100000000",
"0111111110",
"0111111110",
"0110000010",
"0110000010",
"0000000010",
"0111111110",
"0000000000"
    },
    {//7
"0000000000",
"0111111110",
"0100000010",
"0100000010",
"0100000010",
"0100000010",
"0000000010",
"0000000010",
"0000000010",
"0000000010",
"0000000010",
"0000000000"
    },
    {//8
"0000000000",
"0111111110",
"0100000010",
"0100000010",
"0100000010",
"0111111110",
"0111111110",
"0100000010",
"0100000010",
"0100000010",
"0111111110",
"0000000000"
    },
    {//9
"0000000000",
"0111111110",
"0100000010",
"0100000010",
"0100000010",
"0111111110",
"0111111110",
"0000000010",
"0000000010",
"0000000010",
"0111111110",
"0000000000"
    },
        {//0

"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111"
    },
    {//1
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001"
    },
    {//2

"1111111111",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"1111111111",
"1111111111",
"1000000000",
"1000000000",
"1000000000",
"1000000000",
"1111111111",
    },
    {//3
"1111111111",
"0000000011",
"0000000011",
"0000000011",
"0000000011",
"0000111111",
"0000111111",
"0000000011",
"0000000011",
"0000000011",
"0000000011",
"1111111111",
    },
    {//4
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111",
"1111111111",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001"
    },
    {//5

"1111111111",
"1000000000",
"1000000000",
"1000000000",
"1000000000",
"1111111111",
"1111111111",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"1111111111",
    },
    {//6
"1111111111",
"1000000000",
"1000000000",
"1000000000",
"1000000000",
"1111111111",
"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111"
    },
    {//7
"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"0000000001"
    },
    {//8
"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111",
"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111"
    },
    {//9
"1111111111",
"1000000001",
"1000000001",
"1000000001",
"1000000001",
"1111111111",
"1111111111",
"0000000001",
"0000000001",
"0000000001",
"0000000001",
"1111111111"
    }
};

map<pair<int,pair<int,int>>, int>RGB2F;
int rr,gg,bb,mxx;
int comp[4][15][15];
void calcPrePre(string &s,int x,int y)
{
    int sum=0,nn = s.size(),st=0,now,pt=0,a,b;
    char line[5];
    for(int i = 0; i<=nn; i++)
    {
//        cout<<"|"<<s[i]<<"|"<<endl;
        if(s[i]==','||s[i]==' '||s[i] ==0)
        {
            line[st]=0;
            sscanf(line,"%d", &now);
            if(pt==0) a = now;
            else if(pt==1) b = now;

            sum+=now;
            st = 0;
            pt++;
//            pt%=3;
        }
        else line[st++]=s[i];
    }

    comp[0][x/nd][y/md]++;
    comp[1][x/nd][y/md]+=a;
    comp[2][x/nd][y/md]+=b;
    comp[3][x/nd][y/md]+=now;

    return ;
}
void calcPre(int x, int y)
{

    if(comp[0][x][y]){comp[1][x][y]/=comp[0][x][y];
    comp[2][x][y]/=comp[0][x][y];
    comp[3][x][y]/=comp[0][x][y];}
    int a = comp[1][x][y];
    int b = comp[2][x][y];
    int now = comp[3][x][y];
    RGB2F[ {a,{b,now}}]++;
    if(mxx<RGB2F[ {a,{b,now}} ])
    {
        mxx = RGB2F[ {a,{b,now}} ];
        rr = a;
        gg = b;
        bb = now;
    }

    return;
}



bool calc(int x, int y)
{
    int a = comp[1][x][y];
    int b = comp[2][x][y];
    int now = comp[3][x][y];
    return !(a==rr&&b==gg&&now==bb);
}

void print(int t, bool g[][15])
{
    int l;
    l = 10;
//    l = 10;
    for (int i = 0; i<12; i++)
    {
        cout<<"\"";
        for (int j = t; j<t+l; j++)
            cout<<g[i][j];
        cout<<"\""<<", "[n-1==i]<<endl;
    }
    cout<<endl;
}

void getInCur(int x)
{
    for (int i = 0; i<12; i++)
        for (int j = 0; j<10; j++)
            cur[i][j] = chars[x][i][j]=='1';
//            print(0,cur);
}


int getN(int t)
{
    int mx=0;
    char ind=0;
    for (int i = 0; i<30; i++)
    {
        getInCur(i);
        int cnt = 0;
        for (int j = 0; j<12; j++)
        {
            for (int k = 0; k<10; k++)
                if(cur[j][k]==grid[j][k])cnt++;
        }
        if(cnt>mx)
        {
            mx = cnt;
            ind = i%10;
        }
        cerr<<i<<"="<<cnt<<endl;
    }
    return ind;
}

int main()
{
#ifdef ENAM
    	fread;
//	fwrite;
#endif // ENAM
    int t, cas=1;
    _
//    clock_t begin, end;
//    double time_spent;
//    begin = clock();
    string s;
    cin>>n>>m;
    nd = n/12+n%12;
    md = m/10+m%10;
//    cout<<n<<" : "<<m<<endl;
    for (int i = 0; i<n; i++)
        for (int j = 0; j<m; j++)
        {
            cin>>s;
//            cout<<s<<endl;
            calcPrePre(s,i,j);
        }

//        cout<<mxx<<"="<<rr<<":"<<gg<<":"<<bb<<endl;
//        return 0;
    for (int i = 0; i<12; i++)
        for (int j = 0; j<10; j++)
        {
//            cout<<i<<"---------"<<j<<endl;
            calcPre(i,j);
        }
    for (int i = 0; i<12; i++)
        for (int j = 0; j<10; j++)
        {
//            cout<<i<<"---------"<<j<<endl;
            grid[i][j] = calc(i,j);
        }
        print(0,grid);

    cout<<getN(0);


//    end = clock();
//    time_spent = (double)(end - begin) / CLOCKS_PER_SEC;
//    cerr<<"Time spent = "<<time_spent<<endl;

   return 0;
}
