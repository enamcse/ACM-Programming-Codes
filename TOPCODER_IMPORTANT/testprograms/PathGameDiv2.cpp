#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class PathGameDiv2
{
public:
    int now[2][100];
    int calc(vector <string> board)
    {
        int n = board[0].size(), ans=0,path=0, k=0, tew=0;
        clr(now,0);
        for (int i = 0; i<n; i++)
        {
            if(board[k][i]=='#')
            {
                k^=1;
                path++;
            }
        }
        k=1;
        for (int i = 0; i<n; i++)
        {
            if(board[k][i]=='#')
            {
                k^=1;
                tew++;
            }
        }
        if(path<=tew)
        {
            k=0;
            for (int i = 0; i<n-1; i++)
            {
                now[k][i]=1;
                if(board[k][i+1]=='#')
                {
                    k^=1;
                    now[k][i]=1;
                }
            }
            now[k][n-1]=1;
        }
        else
        {
            k=1;
            for (int i = 0; i<n-1; i++)
            {
                now[k][i]=1;
                if(board[k][i+1]=='#')
                {
                    k^=1;
                    now[k][i]=1;
                }
            }
            now[k][n-1]=1;
        }

        for (int i = 0; i<n; i++)
        {
            cout<<now[0][i]<<' ';
        }
        cout<<endl;
        for (int i = 0; i<n; i++)
        {
            cout<<now[1][i]<<' ';
        }
        cout<<endl;


        for (int i =0; i<n; i++)
        {
            if(!now[0][i]&&board[0][i]=='.') ans++;
            if(!now[1][i]&&board[1][i]=='.') ans++;
        }

        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << "\"" << p0[i] << "\"";
    }
    cout << "}";
    cout << "]" << endl;
    PathGameDiv2 *obj;
    int answer;
    obj = new PathGameDiv2();
    clock_t startTime = clock();
    answer = obj->calc(p0);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p1 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p1;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <string> p0;
    int p1;

    // ----- test 0 -----
    disabled = false;
    p0 = {"#....","...#."};
    p1 = 2;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {"#","."};
    p1 = 0;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {".","."};
    p1 = 1;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {"....#.##.....#...........","..#......#.......#..#...."};
    p1 = 13;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// Cat Snuke is playing the Path Game.
//
// The Path Game is played on a rectangular grid of square cells.
// The grid has 2 rows and some positive number of columns.
// Each cell is either black or white.
//
// A left-to-right path in the grid is a sequence of white cells such that the first cell in the sequence is in the leftmost column, the last cell in the sequence is in the rightmost column, and each pair of consecutive cells shares a common side.
//
// The initial coloring of the grid is such that there is at least one left-to-right path.
// You are given this initial coloring as a vector <string> board with two elements.
// For each i and j, board[i][j] is either '#' (representing a black cell) or '.' (representing a white cell).
//
// Snuke may color some of the white cells black.
// After he does so, there must still be at least one left-to-right path left on the board.
// The goal of the game is to color as many cells black as possible.
// Compute and return the largest number of cells Snuke can color black.
// (Note that the cells that are already black do not count.)
//
// DEFINITION
// Class:PathGameDiv2
// Method:calc
// Parameters:vector <string>
// Returns:int
// Method signature:int calc(vector <string> board)
//
//
// CONSTRAINTS
// -board will contain 2 elements.
// -Each element in board will contain between 1 and 50 characters, inclusive.
// -All elements in board will have the same length.
// -Each character in board will be '#' or '.'.
// -The grid described by board will contain a left-to-right path.
//
//
// EXAMPLES
//
// 0)
// {"#...."
// ,"...#."}
//
// Returns: 2
//
// Snuke can color at most two white cells black.
// One possible final state of the board looks as follows:
//
// #....
// ..###
//
//
// 1)
// {"#"
// ,"."}
//
// Returns: 0
//
// Snuke can't color any cells.
//
// 2)
// {"."
// ,"."}
//
// Returns: 1
//
//
//
// 3)
// {"....#.##.....#..........."
// ,"..#......#.......#..#...."}
//
// Returns: 13
//
//
//
// END KAWIGIEDIT TESTING
