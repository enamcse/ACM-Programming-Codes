#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class BearAttacks {
public:
	int expectedValue(int N, int R0, int A, int B, int M, int LOW, int HIGH) {
		
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, int p4, int p5, int p6, bool hasAnswer, int p7) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4 << "," << p5 << "," << p6;
	cout << "]" << endl;
	BearAttacks *obj;
	int answer;
	obj = new BearAttacks();
	clock_t startTime = clock();
	answer = obj->expectedValue(p0, p1, p2, p3, p4, p5, p6);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p7 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p7;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	int p5;
	int p6;
	int p7;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 3;
	p1 = 0;
	p2 = 2;
	p3 = 3;
	p4 = 100;
	p5 = 938593850;
	p6 = 1000000000;
	p7 = 21;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 3;
	p1 = 0;
	p2 = 0;
	p3 = 0;
	p4 = 1;
	p5 = 0;
	p6 = 0;
	p7 = 23;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 6;
	p1 = 303840291;
	p2 = 848660283;
	p3 = 395739574;
	p4 = 950123456;
	p5 = 0;
	p6 = 1000000000;
	p7 = 3856;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 1;
	p1 = 0;
	p2 = 0;
	p3 = 0;
	p4 = 1;
	p5 = 0;
	p6 = 0;
	p7 = 1;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 19;
	p1 = 384038999;
	p2 = 938592393;
	p3 = 692854433;
	p4 = 1000000000;
	p5 = 300000000;
	p6 = 600000000;
	p7 = 473263988;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Limak is a grizzly bear.
// He is currently making plans to attack Deerland.
// 
// Deerland has N cities, numbered from 0 to N-1.
// The cities are all connected together by a network of roads.
// There are exactly N-1 bidirectional roads, each connecting two cities.
// (Hence, the topology of Deerland is a tree.)
// 
// Limak will attack each city in Deerland exactly once.
// For each i, when he attacks city i, there are two possible outcomes:
// 
// With probability 1/(i+1) the city will defend itself successfully.
// In all other cases the city is destroyed by Limak. The city disappears from Deerland, along with all roads that led into the city.
// 
// 
// Let's define a region as a connected component of Deerland.
// In other words, a region is a maximal group of cities such that the existing roads allow us to travel between any two cities in the group.
// Initially, the entire Deerland is a single region.
// After Limak's N attacks Deerland will be divided into one or more regions.
// 
// The strength of a region is the square of the number of cities it contains.
// 
// You are given a description of Deerland in a format that is specified below.
// Let E be the expected value of the sum of strengths of all regions after Limak attacks Deerland.
// It can be proved that E*N! is an integer.
// Return this integer modulo 1,000,000,007.
// 
// The description of Deerland is provided in the form of a pseudorandom generator.
// You are given the ints N, R0, A, B, M, LOW, and HIGH.
// As defined above, N is the number of cities in Deerland.
// The list of roads is generated by the pseudocode below.
// 
// 
// R = R0;
// BILLION = 1000000000;
// for i between 1 and N-1, inclusive:
//     R = (A * R + B) modulo M;
//     MIN = ((i-1) * LOW)  / BILLION;
//     MAX = ((i-1) * HIGH) / BILLION;
//     there is a road between city i and city MIN + (R modulo (MAX-MIN+1));
// 
// 
// Both divisions in the pseudocode are integer divisions.
// (Integer division rounds down. For example, 29/10 is 2.)
// You may assume that the pseudocode always generates a valid tree.
// Watch out for integer overflow when implementing it.
// 
// DEFINITION
// Class:BearAttacks
// Method:expectedValue
// Parameters:int, int, int, int, int, int, int
// Returns:int
// Method signature:int expectedValue(int N, int R0, int A, int B, int M, int LOW, int HIGH)
// 
// 
// CONSTRAINTS
// -N will be between 1 and 1,000,000, inclusive.
// -M will be between 1 and 1,000,000,000, inclusive.
// -R0, A and B will be between 0 and M-1, inclusive.
// -LOW and HIGH will be between 0 and 1,000,000,000, inclusive.
// -LOW will not be greater than HIGH.
// 
// 
// EXAMPLES
// 
// 0)
// 3
// 0
// 2
// 3
// 100
// 938593850
// 1000000000
// 
// Returns: 21
// 
// There are N=3 cities.
// The generator outputs that the two roads are 1-0 and 2-1.
// Hence, Deerland is the path 0-1-2.
// Here is what may happen:
// 
// With probability (1/1) * (1/2) * (1/3) = 1/6 all three cities survive. In this case we have a single region with strength 9.
// With probability (1/1) * (1/2) * (2/3) = 2/6 only cities 0 and 1 survive. We have one region with strength 4.
// With probability (1/1) * (1/2) * (1/3) = 1/6 only cities 0 and 2 survive. Here we have two regions, each with strength 1, hence the total strength is 2.
// With probability (1/1) * (1/2) * (2/3) = 2/6 only city 0 survives. There is only one region and its strength is 1.
// 
// Therefore, the expected sum of regions' strengths is (1/6)*9 + (2/6)*4 + (1/6)*2 + (2/6)*1 = 21/6.
// The correct return value is ( (21/6) * N! ) modulo 1,000,000,007, which is 21.
// 
// 1)
// 3
// 0
// 0
// 0
// 1
// 0
// 0
// 
// Returns: 23
// 
// Again there are three cities, but now the roads are 1-0 and 2-0.
// A different set of roads leads to a different answer.
// 
// 2)
// 6
// 303840291
// 848660283
// 395739574
// 950123456
// 0
// 1000000000
// 
// Returns: 3856
// 
// Six cities. Roads: 1-0, 2-1, 3-1, 4-3, 5-1.
// 
// 3)
// 1
// 0
// 0
// 0
// 1
// 0
// 0
// 
// Returns: 1
// 
// 
// 
// 4)
// 19
// 384038999
// 938592393
// 692854433
// 1000000000
// 300000000
// 600000000
// 
// Returns: 473263988
// 
// 
// 
// END KAWIGIEDIT TESTING
