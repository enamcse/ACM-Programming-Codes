#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class NumberGameAgain
{
public:

    int level(ll now)
    {
        for (int i = 45; i>=0; i--)
            if((1LL<<i)&now) return i;
        return 0;
    }
    bool check(ll par, ll child)
    {
        int stpr=level(par), stch=level(child);
        if(stpr>=stch) return false;
        for (int i = stpr, j = stch; i>=0; i--, j--)
            if((((par&(1LL<<i))!=0) ^  (0!=(child&(1LL<<j))))) return false;

        return true;
    }

    long long solve(int k, vector<long long> table)
    {
        ll ans=(1LL<<k)-2;
        sort(all(table));
        vector<ll>counted;
        for (int i = 0; i<table.size(); i++)
        {
            bool flag = true;
            for (int j = 0; j<counted.size(); j++)
            {

                if(check(counted[j],table[i]))
                {
                    flag = false;
                    break;
                }
            }
            if(flag)
            {
                int lev = level(table[i]);
                ans-=((1LL<<(k-lev))-1LL);
                counted.pb(table[i]);
            }
        }
        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector<long long> p1, bool hasAnswer, long long p2)
{
    cout << "Test " << testNum << ": [" << p0 << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    NumberGameAgain *obj;
    long long answer;
    obj = new NumberGameAgain();
    clock_t startTime = clock();
    answer = obj->solve(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p2 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p2;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    int p0;
    vector<long long> p1;
    long long p2;

    // ----- test 0 -----
    disabled = false;
    p0 = 3;
    p1 = {2ll,4ll,6ll};
    p2 = 2ll;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = 5;
    p1 = {2ll,3ll};
    p2 = 0ll;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = 5;
    p1 = {};
    p2 = 30ll;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = 40;
    p1 = {2ll,4ll,8ll,16ll,32141531ll,2324577ll,1099511627775ll,2222222222ll,33333333333ll,4444444444ll,2135ll};
    p2 = 549755748288ll;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = 40;
    p1 = {};
    p2 = 1099511627774ll;
    all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// In this problem, you are going to play a simple number game.
// The rules of the game are as follows:
//
// You have a single variable called x. Initially, x is set to 1.
// In each step, you can change the value of x either to 2x or to 2x+1.
// You are given a list of forbidden values. If at any moment your x is on the list, you lose the game.
// You are also given a target value y. If at any moment your x is equal to y, you win the game. (Note that the previous item applies sooner: if y is forbidden, you lose the game when you reach it.)
// If at any moment winning the game becomes impossible, you lose the game.
//
//
//
//
// For example, assume that the forbidden values are 4 and 7, and the goal is 12.
// You can win the game as follows: change x from 1 to 2*1+1=3, then from 3 to 2*3=6, and then from 6 to 2*6=12.
//
//
//
// You are given a vector<long long> table.
// The elements of table are the forbidden values.
//
//
//
// You are also given a int k.
// Consider all possible goals y between 2 and (2^k)-1, inclusive.
// For how many of these goals is it possible to win the game?
// Compute and return the answer to that question.
//
//
// DEFINITION
// Class:NumberGameAgain
// Method:solve
// Parameters:int, vector<long long>
// Returns:long long
// Method signature:long long solve(int k, vector<long long> table)
//
//
// CONSTRAINTS
// -k will be between 2 and 40, inclusive.
// -The number of elements in table will be between 0 and 20, inclusive.
// -all numbers in table will be between 2 and 2^k - 1, inclusive.
// -all numbers in table will be distinct.
//
//
// EXAMPLES
//
// 0)
// 3
// {2,4,6}
//
// Returns: 2
//
// There are three forbidden values: 2, 4, and 6.
// As k=3, we are considering y between 2 and (2^3)-1 = 7.
// This is how the game would end for each of these y's:
//
// For y=2 we cannot win the game because 2 is forbidden.
// For y=3 we can win the game: we change x from 1 to 3.
// For y=4 we cannot win the game because 4 is forbidden.
// For y=5 we cannot win the game. We would need to change x from 1 to 2 and then from 2 to 5, but we cannot do that because 2 is forbidden.
// For y=6 we cannot win the game because 6 is forbidden.
// For y=7 we can win the game: we change x from 1 to 3, and then from 3 to 7.
//
// Thus, within the specified range there are two values of y for which we can win the game.
//
//
// 1)
// 5
// {2,3}
//
// Returns: 0
//
// In this case, we will always reach a forbidden value after the very first step of the game. Therefore, there is no y for which we can win the game.
//
// 2)
// 5
// {}
//
// Returns: 30
//
// With no forbidden values we can win this game for any y between 2 and 31, inclusive.
//
// 3)
// 40
// {2,4,8,16,32141531,2324577,1099511627775,2222222222,33333333333,4444444444,2135}
//
// Returns: 549755748288
//
//
//
// 4)
// 40
// {}
//
// Returns: 1099511627774
//
//
//
// END KAWIGIEDIT TESTING
