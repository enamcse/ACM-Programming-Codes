#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class NoRightTurnDiv2
{
public:

    struct point
    {
        int x, y;
        point() {}
        point(int a, int b)
        {
            x = a;
            y = b;
        }
    };


    bool check(const point &O, const point &A, const point &B) //checks rotation
    {
        int rotation = (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
//        if(rotation == 0) return 0;
        return rotation > 0? true : false;
    }

    bool col[100];


    vector <int> findPath(vector <int> x, vector <int> y)
    {
        vector<int>ans;
        int n = x.size();
        int now = 0;
        ans.clear();
        pair<int,int> mn = make_pair(x[0],y[0]);
        for (int i = 1; i<n; i++)
            if(mn>make_pair(x[i],y[i]))
                {
                    mn = {x[i],y[i]};
                    now = i;
                }
        clr(col,false);
        ans.pb(now);
        col[now] = true;
        for (int i = 1; i<n; i++)
            for (int j = 0; j<n; j++)
            {
                if(!col[j])
                {
                    bool flag = true;
                    for (int k = 0; k<n; k++)
                        if(j!=k&&!col[k])flag&=check(point(x[now],y[now]), point(x[j],y[j]),point(x[k],y[k]));
                    if(flag)
                    {
                        now = j;
                        col[now] = true;
                        ans.pb(now);
                        break;
                    }
                }
            }

        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, vector <int> p2)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    NoRightTurnDiv2 *obj;
    vector <int> answer;
    obj = new NoRightTurnDiv2();
    clock_t startTime = clock();
    answer = obj->findPath(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "{";
        for (int i = 0; int(p2.size()) > i; ++i)
        {
            if (i > 0)
            {
                cout << ",";
            }
            cout << p2[i];
        }
        cout << "}" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "{";
    for (int i = 0; int(answer.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << answer[i];
    }
    cout << "}" << endl;
    if (hasAnswer)
    {
        if (answer.size() != p2.size())
        {
            res = false;
        }
        else
        {
            for (int i = 0; int(answer.size()) > i; ++i)
            {
                if (answer[i] != p2[i])
                {
                    res = false;
                }
            }
        }
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <int> p0;
    vector <int> p1;
    vector <int> p2;

    // ----- test 0 -----
    disabled = false;
    p0 = {-10,0,10};
    p1 = {10,-10,10};
    p2 = {0,1,2};
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {0,0,-3,-3,3,3};
    p1 = {-1,1,-3,3,-3,3};
    p2 = {0,4,5,3,2,1};
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {10,9,8,7,6,5,4,3,2,1};
    p1 = {1,4,9,16,25,36,49,64,81,100};
    p2 = {9,8,7,6,5,4,3,2,1,0};
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {0,2,-2,4,-4,2,-2,0};
    p1 = {1,2,2,4,4,6,6,5};
    p2 = {4,2,0,1,3,5,6,7};
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = {-76,98,83,58,-15,94,21,55,80,84,-39,-90,-46,100,-80,-49,-2,-70,36,48,88,10,55,-56,22,67,31,81,100,-39,64,-62,-7,45,-82,-24,51,-33,53,11,20,-74,-83,47,9,39,42,63,-97,94};
    p1 = {-90,68,91,-92,-6,88,99,10,39,-69,-61,-4,71,-5,90,-51,21,-53,-21,-86,41,-9,42,-23,-4,12,94,-59,55,18,70,-88,-86,-17,-97,-33,87,80,91,-80,-79,-79,-78,-99,57,67,-52,-46,61,-10};
    p2 = {39,32,40,31,19,27,47,46,0,34,43,3,9,13,28,1,5,2,6,14,48,42,41,49,20,38,26,37,12,11,17,10,33,25,8,30,36,44,29,23,15,18,7,22,45,16,4,35,24,21};
    all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// Roger the Robot has been sent to explore a planet.
// The surface of the planet can be thought of as a two-dimensional plane.
// You are given two vector <int>s x and y.
// The planet has N interesting points described by these vector <int>s.
// The i-th interesting point has coordinates (x[i], y[i]).
// No three interesting points will be collinear.
//
//
//
// Roger will choose a permutation of {0,1,...,N-1}, and will visit the points in that order.
// Roger will travel in a straight line in between points. There are two conditions he must follow:
//
// He must never cross his own path (that is, if we look at the line segments formed by the path, no two segments strictly intersect).
//  Due to rather unfortunate oversight, Roger is incapable of making any right turns. This means that for any three consecutive points that he visits, these three points constitute a counter-clockwise orientation.
//
//
//
//
// Your job is to find a path that Roger can take.
// If there is no valid path, return an empty vector <int>.
// Otherwise, return an vector <int> containing a permutation of 0,...,N-1, representing a valid path that Roger can take.
//
//
//
//
// DEFINITION
// Class:NoRightTurnDiv2
// Method:findPath
// Parameters:vector <int>, vector <int>
// Returns:vector <int>
// Method signature:vector <int> findPath(vector <int> x, vector <int> y)
//
//
// CONSTRAINTS
// -x will contain between 2 and 50 elements, inclusive.
// -y will contain exactly the same number of elements as x.
// -Each element of x,y will be between -1,000 and 1,000, inclusive.
// -All pairs (x[i], y[i]) will be distinct.
// -No three points will be collinear.
//
//
// EXAMPLES
//
// 0)
// {-10, 0, 10}
// {10, -10, 10}
//
// Returns: {0, 1, 2 }
//
// The points form a triangle.
// Any of the following return values will be accepted: {0,1,2},{1,2,0},{2,0,1}
//
// 1)
// {0,0,-3,-3,3,3}
// {-1,1,-3,3,-3,3}
//
// Returns: {0, 4, 5, 3, 2, 1 }
//
//
// Here is a picture of the points:
//
//
//
//
//
//
//
// Here is an example of a different valid solution. This would correspond to a return value of {1,5,3,2,4,0}
//
//
//
//
//
//
// 2)
// {10,9,8,7,6,5,4,3,2,1}
// {1,4,9,16,25,36,49,64,81,100}
//
// Returns: {9, 8, 7, 6, 5, 4, 3, 2, 1, 0 }
//
//
//
// 3)
// {0, 2,-2, 4,-4, 2,-2, 0}
// {1, 2, 2, 4, 4, 6, 6, 5}
//
// Returns: {4, 2, 0, 1, 3, 5, 6, 7 }
//
//
//
// 4)
// {-76,98,83,58,-15,94,21,55,80,84,-39,-90,-46,100,-80,-49,-2,-70,36,48,88,10,
// 55,-56,22,67,31,81,100,-39,64,-62,-7,45,-82,-24,51,-33,53,11,20,-74,-83,47,
// 9,39,42,63,-97,94}
// {-90,68,91,-92,-6,88,99,10,39,-69,-61,-4,71,-5,90,-51,21,-53,-21,-86,41,-9,
// 42,-23,-4,12,94,-59,55,18,70,-88,-86,-17,-97,-33,87,80,91,-80,-79,-79,-78,
// -99,57,67,-52,-46,61,-10}
//
// Returns: {39, 32, 40, 31, 19, 27, 47, 46, 0, 34, 43, 3, 9, 13, 28, 1, 5, 2, 6, 14, 48, 42, 41, 49, 20, 38, 26, 37, 12, 11, 17, 10, 33, 25, 8, 30, 36, 44, 29, 23, 15, 18, 7, 22, 45, 16, 4, 35, 24, 21 }
//
//
//
// END KAWIGIEDIT TESTING
