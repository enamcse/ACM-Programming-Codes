#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class TheGridDivTwo
{
public:
    int K;
    const int con = 1002;
    bool blocked[2010][2010];
    bool col[2010][2010];
//    set< pair<int,int> >blocked;
//    map<pair<int,int>, bool >col;
    int ans;
    void bfs(pair<int,int>p, int c)
    {
        col[ p.first ][ p.second ] = true;
        queue<pair< pair<int,int>, int> >q;
        q.push({p,c});
        while(!q.empty())
        {
            pair< pair<int,int>, int> now=q.front();
            q.pop();
//            cout<<now.first.first<<" "<<now.first.second<<" : "<<now.second<<" <= "<<K<<endl;
            ans = max(ans,now.first.first);
            if(now.second==K) continue;
            for (int i = -1; i<2; i++)
                for (int j = -1; j<2; j++)
                {
                    if(!((i==0)^(j==0))) continue;
                    pair<int,int> nowa = now.first;
                    nowa.first = now.first.first+i;
                    nowa.second = now.first.second+j;
                    if(!col[nowa.first][nowa.second] && !blocked[nowa.first][nowa.second] ) {col[ nowa.first ][nowa.second] = true; q.push({nowa,now.second+1});}
                }
        }
    }


    int find(vector <int> x, vector <int> y, int k)
    {
        K = k;
        int n = x.size();
//        blocked.clear();
//        col.clear();
        clr(blocked,0);
        clr(col,0);
        ans = 0;

        for (int i = 0; i<n; i++)
            blocked[x[i] + con ][ y[i] + con]=true;

        bfs({con,con},0);
        return ans-con;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, int p2, bool hasAnswer, int p3)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}" << "," << p2;
    cout << "]" << endl;
    TheGridDivTwo *obj;
    int answer;
    obj = new TheGridDivTwo();
    clock_t startTime = clock();
    answer = obj->find(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p3;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <int> p0;
    vector <int> p1;
    int p2;
    int p3;

    // ----- test 0 -----
    disabled = false;
    p0 = {1,1,1,1};
    p1 = {-2,-1,0,1};
    p2 = 4;
    p3 = 2;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {-1,0,0,1};
    p1 = {0,-1,1,0};
    p2 = 9;
    p3 = 0;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {};
    p1 = {};
    p2 = 1000;
    p3 = 1000;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {1,0,0,-1,-1,-2,-2,-3,-3,-4,-4};
    p1 = {0,-1,1,-2,2,-3,3,-4,4,-5,5};
    p2 = 47;
    p3 = 31;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = {1, 35, 7, 67, 94, 50, 14, 65, 96, 89, 84, 11, 63, 9, 5, 85, 18, 73, 19, 17, 30, 61, 50, 64, 42, 26, 80, 68, 23, 84, 37, 48, 46, 68, 15, 55, 79, 23, 10, 88, 51, 73, 78, 48, 3, 76}; ;
    p1 = {-4, -3, -1, 0, -1, 3, 0, -4, 3, 2, 4, -1, 2, 4, 2, 1, 2, 1, -3, 1, -3, 1, 0, -2, 1, -2, 0, 3, 0, 2, -1, -4, -3, -3, -4, -3, -2, -1, -4, -1, 4, -3, -1, 0, 2, 4};
    p2 = 994;
    p3 = 989;
    all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// John is standing at the origin of an infinite two-dimensional grid.
// He is going to move along this grid.
// During each second he can either stay where he is or he can move by one unit in one of the four cardinal directions (north, south, east, or west).
// Some of the grid points are blocked.
// John is not allowed to move to a blocked grid point.
//
//
// You are given the coordinates of the blocked grid points as vector <int>s x and y.
// For each valid i, the grid point that is x[i] units east and y[i] units north of the origin is blocked.
// You are also given an int k.
// Compute and return the maximal possible x-coordinate of a point John can reach in k seconds.
//
//
// DEFINITION
// Class:TheGridDivTwo
// Method:find
// Parameters:vector <int>, vector <int>, int
// Returns:int
// Method signature:int find(vector <int> x, vector <int> y, int k)
//
//
// CONSTRAINTS
// -x will contain between 0 and 47 elements, inclusive.
// -x and y will contain the same number of elements.
// -Each element of x will be between -1,000 and 1,000, inclusive.
// -Each element of y will be between -1,000 and 1,000, inclusive.
// -All pairs (x[i], y[i]) will be distinct.
// -Each pair (x[i], y[i]) will be different from (0, 0).
// -k will be between 1 and 1,000, inclusive.
//
//
// EXAMPLES
//
// 0)
// {1,1,1,1}
// {-2,-1,0,1}
// 4
//
// Returns: 2
//
// The optimal strategy is to move two times north to (0, 2) and then two times east to (2,2).
//
//
// 1)
// {-1, 0, 0, 1}
// {0, -1, 1, 0}
// 9
//
// Returns: 0
//
// John can not make any moves.
//
// 2)
// {}
// {}
// 1000
//
// Returns: 1000
//
//
//
// 3)
// {1,0,0,-1,-1,-2,-2,-3,-3,-4,-4}
// {0,-1,1,-2,2,-3,3,-4,4,-5,5}
// 47
//
// Returns: 31
//
//
//
// END KAWIGIEDIT TESTING
