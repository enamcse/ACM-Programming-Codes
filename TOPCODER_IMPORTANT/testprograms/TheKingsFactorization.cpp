#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              2000005
#define V(a)            vector<(a)>

using namespace std;

int primes[SZ],cnt=1;
bool siv[SZ];
map<int,int>mp;
class TheKingsFactorization
{
public:
    void seive()
    {
        int sq = sqrt(SZ);
        for (int i = 3; i<=sq; i+=2)
        {
            if(!siv[i])
                for (int j = i*i; j<SZ; j+=i+i)
                    siv[j]=true;
        }
        primes[cnt]=2;
        mp[2]=cnt;
        cnt++;
        for (int i = 3; i<SZ; i+=2)
            if(!siv[i])
            {
                primes[cnt]=i;
                mp[i]=cnt;
                cnt++;
            }
    }

    vector<long long> getVector(long long N, vector<long long> p)
    {
        if(p.size()==1) ///case of only one or two prime divisor whatever the range of the number
        {
            if(N%p[0]==0&&N/p[0]>1)
            {
                p.pb(N/p[0]);
                sort(all(p));
            }
            return p;
        }


        seive();///generating primes up to 10^6
        int n = p.size(),en=1;
        vector<long long>ans(all(p));


        for (int i = 0; i<n; i++) N/=p[i];
        while(N>1)
        {
            if(en==n)///only last one or zero prime is remaining
            {
                if(N==1) continue;
                ans.pb(N);
                N/=N;
                en++;
                break;
            }
            int last = mp.find(p[en])==mp.end()?cnt:mp[p[en]]+1;
            for (int i = mp[p[en-1]]; i<last; i++)
            {
                if(N%primes[i]==0)
                {
                    N/=primes[i];
                    ans.pb(primes[i]);
                    break;
                }
            }
            en++;
        }

        sort(all(ans));
        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, vector<long long> p1, bool hasAnswer, vector<long long> p2)
{
    cout << "Test " << testNum << ": [" << p0 << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    TheKingsFactorization *obj;
    vector<long long> answer;
    obj = new TheKingsFactorization();
    clock_t startTime = clock();
    answer = obj->getVector(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << "{";
        for (int i = 0; int(p2.size()) > i; ++i)
        {
            if (i > 0)
            {
                cout << ",";
            }
            cout << p2[i];
        }
        cout << "}" << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << "{";
    for (int i = 0; int(answer.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << answer[i];
    }
    cout << "}" << endl;
    if (hasAnswer)
    {
        if (answer.size() != p2.size())
        {
            res = false;
        }
        else
        {
            for (int i = 0; int(answer.size()) > i; ++i)
            {
                if (answer[i] != p2[i])
                {
                    res = false;
                }
            }
        }
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    long long p0;
    vector<long long> p1;
    vector<long long> p2;

    // ----- test 0 -----
    disabled = false;
    p0 = 12ll;
    p1 = {2ll,3ll};
    p2 = {2ll,2ll,3ll};
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = 7ll;
    p1 = {7ll};
    p2 = {7ll};
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = 1764ll;
    p1 = {2ll,3ll,7ll};
    p2 = {2ll,2ll,3ll,3ll,7ll,7ll};
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = 49ll;
    p1 = {7ll};
    p2 = {7ll,7ll};
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = 210ll;
    p1 = {2ll,5ll};
    p2 = {2ll,3ll,5ll,7ll};
    all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 5 -----
    disabled = false;
    p0 = 100000ll;
    p1 = {2ll,2ll,2ll,5ll,5ll};
    p2 = {2ll,2ll,2ll,2ll,2ll,5ll,5ll,5ll,5ll,5ll};
    all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// The King of Byteland likes integer factorization.
// Your task is to help him factor the number N.
// You will be given the long long N and you should return a vector<long long> containing all prime factors of N sorted in non-decreasing order.
// Note that some primes may occur multiple times in the prime factorization of N.
// For example, for N = 60 the only correct return value is {2, 2, 3, 5} because 2*2*3*5 = 60.
//
//
//
//
// To make this task easier, the King has decided to give you a hint.
// He already knows the correct factorization and he will tell you every second number in the correct return value.
// More precisely, in addition to N you will be given a vector<long long> primes.
// The number of elements in primes will be (M+1)/2, rounded down, where M is the number of elements in the correct return value.
// For each valid i, primes[i] will be equal to the element 2i of the correct return value.
// (All indices are 0-based.)
//
//
//
//
// Given N and primes, return the vector<long long> containing the factorization of N.
//
//
// DEFINITION
// Class:TheKingsFactorization
// Method:getVector
// Parameters:long long, vector<long long>
// Returns:vector<long long>
// Method signature:vector<long long> getVector(long long N, vector<long long> primes)
//
//
// CONSTRAINTS
// -N will be between 2 and 1,000,000,000,000,000,000 (10^18), inclusive.
// -primes will contain the correct prime factors (as defined in the problem statement).
//
//
// EXAMPLES
//
// 0)
// 12
// {2, 3}
//
// Returns: {2, 2, 3 }
//
//
//
// 1)
// 7
// {7}
//
// Returns: {7 }
//
//
//
// 2)
// 1764
// {2, 3, 7}
//
// Returns: {2, 2, 3, 3, 7, 7 }
//
//
//
// 3)
// 49
// {7}
//
// Returns: {7, 7 }
//
//
//
// 4)
// 210
// {2, 5}
//
// Returns: {2, 3, 5, 7 }
//
//
//
// 5)
// 100000
// {2, 2, 2, 5, 5}
//
// Returns: {2, 2, 2, 2, 2, 5, 5, 5, 5, 5 }
//
//
//
// END KAWIGIEDIT TESTING
