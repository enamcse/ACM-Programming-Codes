#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class PotentialGeometricSequence {
public:
	int numberOfSubsequences(vector <int> d) {
		int n = d.size(), seq=0;
		int init, now;
		bool flag;
		for (int i = 0; i<n; i++)
        {
            for (int j = i; j<n; j++)
            {
                if(i==j||j==i+1) {seq++;continue;}
                flag = true;
                init = d[i+1]-d[i];
                int k = i+2;
                for (; k<=j; k++)
                {
                    now = d[k]-d[k-1];
                    if(now!=init)
                    {
                        flag = false;
                        break;
                    }
                }
                if(flag) seq++;
            }
        }

		return seq;

	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	PotentialGeometricSequence *obj;
	int answer;
	obj = new PotentialGeometricSequence();
	clock_t startTime = clock();
	answer = obj->numberOfSubsequences(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <int> p0;
	int p1;

	{
	// ----- test 0 -----
	int t0[] = {0,1,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	int t0[] = {1,2,4};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	int t0[] = {3,2,1,0};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 10;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	int t0[] = {1,2,4,8,16};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 9;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	int t0[] = {1,3,5,5,5,5,64,4,23,2,3,4,5,4,3};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 37;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
//
// We have a sequence of N positive integers: a[0] through a[N-1].
// You do not know these integers.
// All you know is the number of trailing zeros in their binary representations.
// You are given a vector <int> d with N elements.
// For each i, d[i] is the number of trailing zeros in the binary representation of a[i].
//
//
//
// For example, suppose that a[0]=40.
// In binary, 40 is 101000 which ends in three zeros.
// Therefore, d[0] will be 3.
//
//
//
// You like geometric sequences.
// (See the Notes section for a definition of a geometric sequence.)
// You would like to count all non-empty contiguous subsequences of the sequence a[0], a[1], ..., a[N-1] that can be geometric sequences (given the information you have in d).
//
//
//
// More precisely:
// For each pair (i,j) such that 0 <= i <= j <= N-1, we ask the following question: "Given the values d[i] through d[j], is it possible that the values a[i] through a[j] form a geometric sequence?"
//
//
//
// For example, suppose that d = {0,1,2,3,2}.
// For i=0 and j=3 the answer is positive: it is possible that the values a[0] through a[3] are {1,2,4,8} which is a geometric sequence.
// For i=1 and j=4 the answer is negative: there is no geometric sequence with these numbers of trailing zeros in binary.
//
//
//
// Compute and return the number of contiguous subsequences of a[0], a[1], ..., a[N-1] that can be geometric sequences.
//
//
// DEFINITION
// Class:PotentialGeometricSequence
// Method:numberOfSubsequences
// Parameters:vector <int>
// Returns:int
// Method signature:int numberOfSubsequences(vector <int> d)
//
//
// NOTES
// -A geometric sequence is any sequence g[0], g[1], ..., g[k-1] such that there is a real number q (the quotient) with the property that for each valid i, g[i+1] = g[i]*q. For example, {1,2,4,8} is a geometric sequence with q=2, {7,7,7} is a geometric sequence with q=1, and {18,6,2} is a geometric sequence with q=1/3.
//
//
// CONSTRAINTS
// -N will be between 1 and 50, inclusive.
// -d will contain exactly N elements.
// -Each element of d will be between 0 and 100, inclusive.
//
//
// EXAMPLES
//
// 0)
// {0,1,2}
//
// Returns: 6
//
// One possibility is that a[0]=3, a[1]=6, and a[2]=12. In this case, all contiguous subsequences of this sequence are geometric.
//
// 1)
// {1,2,4}
//
// Returns: 5
//
// All one-element and two-element subsequences are geometric. The entire sequence cannot be geometric.
//
// 2)
// {3,2,1,0}
//
// Returns: 10
//
//
//
// 3)
// {1,2,4,8,16}
//
// Returns: 9
//
//
//
// 4)
// {1,3,5,5,5,5,64,4,23,2,3,4,5,4,3}
//
// Returns: 37
//
//
//
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
