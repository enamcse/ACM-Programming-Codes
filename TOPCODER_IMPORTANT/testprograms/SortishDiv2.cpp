#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class SortishDiv2 {
public:
    int arr[200];
    int calc_sort(int n)
    {
        int now = 0;
        for (int i = 0; i<n; i++)
        for (int j = i+1; j<n; j++)
            if(arr[i]<arr[j]) now++;
//            cout<<now<<endl;
        return now;
    }
	int ways(int s, vector <int> seq) {
	    int n=seq.size(),m;
	    ll now=0;
	    vector<int>v,tm=seq,ind;
	    sort(all(tm));
	    for (int i = 0; i<n; i++)
	        arr[i]=seq[i];
		for (int i = 1; i<=n; i++)
            if(!binary_search(all(tm), i))v.pb(i);
        for (int i = 0; i<n; i++)
            if(!seq[i]) ind.pb(i);
        m = v.size();
        if(!m) return (int)calc_sort(n)==s;
        do
        {
            for (int i = 0; i<m; i++)
                arr[ind[i]  ] = v[i];
            if(calc_sort(n)==s) now++;
        }
        while(next_permutation(all(v)));
        return now;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}";
	cout << "]" << endl;
	SortishDiv2 *obj;
	int answer;
	obj = new SortishDiv2();
	clock_t startTime = clock();
	answer = obj->ways(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	int p0;
	vector <int> p1;
	int p2;

	// ----- test 0 -----
	disabled = false;
	p0 = 5;
	p1 = {4,0,0,2,0};
	p2 = 2;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = 4;
	p1 = {0,0,0,0};
	p2 = 5;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = false;
	p0 = 2;
	p1 = {1,3,2};
	p2 = 1;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = false;
	p0 = 2;
	p1 = {1,2,0,5,0,0};
	p2 = 0;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Everyone likes some sequences more than others.
// Every person has their own function which tells them how good a sequence is.
// For example, for some people this function could simply be the count of negative numbers in the sequence.
//
// Jezalb's most favorite sequences are ones that are sorted in increasing order.
// When he sees a sequence S, he immediately calculates the number of pairs of indexes i < j such that S[i] < S[j].
// He calls this number the "sortedness" of S.
//
// This morning Jezalb entered a classroom and saw a permutation of 1 through N on the blackboard.
// He quickly calculated its sortedness.
// He then left the classroom and forgot the permutation.
// He only remembered the sortedness he computed.
// You are given this value in a int sortedness.
//
// Later that day Jezalb reentered the classroom and saw a sequence on the blackboard.
// The sequence was a permutation of 1 through N, but with some elements erased.
// You are given this sequence as a vector <int> seq with N elements.
// Some of the elements in seq may be 0, which indicates an erased number.
//
// Jezalb thinks that the sequence seq may have been obtained by erasing some elements of the sequence he saw during his first visit to the classroom.
// He would like to restore the erased elements.
//
// You are given the int sortedness and the vector <int> seq.
// Return the number of ways in which he can fill in the missing elements into seq in such a way that the sortedness of the obtained permutation will be exactly sortedness.
//
// DEFINITION
// Class:SortishDiv2
// Method:ways
// Parameters:int, vector <int>
// Returns:int
// Method signature:int ways(int sortedness, vector <int> seq)
//
//
// CONSTRAINTS
// -sortedness will be between 0 and 1,000,000,000, inclusive.
// -seq will contain between 1 and 100 elements, inclusive.
// -Elements in seq will be between 0 and number of elements in seq, inclusive.
// -Positive elements in seq will be distinct.
// -Number of elements equal to 0 in seq will be between 0 and 5, inclusive.
//
//
// EXAMPLES
//
// 0)
// 5
// {4, 0, 0, 2, 0}
//
// Returns: 2
//
// Regardless of how he fills in the gaps, the sortedness of the resulting permutation will always be greater than 2.
//
// 1)
// 4
// {0, 0, 0, 0}
//
// Returns: 5
//
// All 5 possible ways are: {1, 3, 4, 2}, {1, 4, 2, 3}, {2, 1, 4, 3}, {2, 3, 1, 4}, {3, 1, 2, 4}.
//
// 2)
// 2
// {1, 3, 2}
//
// Returns: 1
//
// There are no gaps and sortedness is indeed equal to 2.
//
// 3)
// 2
// {1, 2, 0, 5, 0, 0}
//
// Returns: 0
//
// Regardless of how he fills in the gaps, the sortedness of the resulting permutation will always be greater than 2.
//
// END KAWIGIEDIT TESTING
