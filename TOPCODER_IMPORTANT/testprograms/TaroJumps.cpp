#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class TaroJumps
{
public:
    int n;
    int dp[60][60];
    vector <int> v;
    int rec(int pos, int pre)
    {
        if(pos == n) return 0;
        int &ret = dp[pos][pre];
        if(ret!= -1) return ret;
        ret = 0;
        ll now=v[pre], dif;
        bool one=false, zero = false, ok = false;
        dif = v[pos] - now;

        for (int j = 31; j>=0; j--)
        {
            if(!one && ((1<<j)&dif )) one = true;
            else if(one && zero && ((1<<j)&dif ))
            {
                ok = false;
                break;
            }
            else if (one && !zero && !((1<<j)&dif )) zero = true, ok = true;
        }

        if(ok) ret = rec(pos+1, pos)+1;
        ret = max(ret, rec(pos+1, pre));
        return ret;
    }

    int getNumber(vector <int> rocks, int A, int B)
    {
        n = rocks.size();
        int ans = 0;
        sort(all(rocks));
        v = rocks;
        clr(dp,-1);
        for (int j = 0; j<n; j++)
            for (int i = 0; i<32; i++)
            {
                ll now =  rocks[j] + 1 - (1LL<<i);

                if(now>=A&&now<=B)
                {
                    ans = max(ans,1+rec(j+1,j));
                    break;
                }
            }
        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, int p1, int p2, bool hasAnswer, int p3)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << p1 << "," << p2;
    cout << "]" << endl;
    TaroJumps *obj;
    int answer;
    obj = new TaroJumps();
    clock_t startTime = clock();
    answer = obj->getNumber(p0, p1, p2);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p3 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p3;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <int> p0;
    int p1;
    int p2;
    int p3;

    // ----- test 0 -----
    disabled = false;
    p0 = {2,6,16};
    p1 = 0;
    p2 = 1;
    p3 = 2;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {2,4,9};
    p1 = 0;
    p2 = 0;
    p3 = 0;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {4,10,3,6};
    p1 = 2;
    p2 = 5;
    p3 = 3;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {1,1000000000};
    p1 = 0;
    p2 = 10;
    p3 = 1;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = {1,47,74,1000000000};
    p1 = 0;
    p2 = 1000000000;
    p3 = 1;
    all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// Cat Taro jumps quite well. He decided to jump onto some rocks.
//
//
//
//
// There are N rocks on a straight line. For each i, rock i (0-based index) is at the coordinate rocks[i].
// Taro starts his travel from a point with an integer coordinate.
// Each time Taro jumps, his coordinate increases.
// For each i, the length of his i-th jump (1-based count) is 2^(i-1).
// That is, his first jump has length 1, his second jump has length 2, his third jump has length 4, and so on.
// If he starts at the coordinate X, his jumps will take him to X+1, then X+3, then X+7, and so on.
//
//
//
//
// Taro wants to maximize the number of times he jumps onto a rock.
// He can start his jumping from any integer point between A and B, inclusive.
// You are given the vector <int> rocks, the int A and the int B.
// Return the maximum possible number of times Taro jumps onto a rock.
//
//
// DEFINITION
// Class:TaroJumps
// Method:getNumber
// Parameters:vector <int>, int, int
// Returns:int
// Method signature:int getNumber(vector <int> rocks, int A, int B)
//
//
// CONSTRAINTS
// -rocks will contain between 1 and 50 elements, inclusive.
// -All elements of rocks will be distinct.
// -Each element of rocks will be between 0 and 1,000,000,000, inclusive.
// -B will be between 0 and 1,000,000,000, inclusive.
// -A will be between 0 and B, inclusive.
//
//
// EXAMPLES
//
// 0)
// {2, 6, 16}
// 0
// 1
//
// Returns: 2
//
// In this test case the valid starting points are 0 and 1.
//
//
// If Taro starts at coordinate 0, he will jump to 1, 3, 7, 15, and so on.
// In this case he will not jump onto any rock.
//
//
// If he starts at coordinate 1, he will jump to 2, 4, 8, 16, and so on.
// In this case, he will jump onto a rock twice: the first time at the coordinate 2, and then at the coordinate 16.
//
//
// Thus, the answer is 2.
//
// 1)
// {2, 4, 9}
// 0
// 0
//
// Returns: 0
//
//
//
// 2)
// {4, 10, 3, 6}
// 2
// 5
//
// Returns: 3
//
// Here the best starting coordinate is 3. Note that Taro does not jump onto his starting coordinate. If there is a rock at the coordinate where he starts, we do not count it.
//
//
// Also note that he can jump onto the rocks in any order.
//
// 3)
// {1, 1000000000}
// 0
// 10
//
// Returns: 1
//
//
//
// 4)
// {1, 47, 74, 1000000000}
// 0
// 1000000000
//
// Returns: 1
//
//
//
// END KAWIGIEDIT TESTING
