#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class Fragile2
{
public:
    vector<int>adj[100];
    bool col[100];
    int n;

    void bfs(int x)
    {
        queue<int>q;
        q.push(x);
        col[x]=true;
        while(!q.empty())
        {
            int u = q.front();

            int v = adj[u].size();
            q.pop();
            for (int i = 0; i<v; i++)
            {
                if(col[adj[u][i] ]) continue;
                q.push(adj[u][i]);
                col[ adj[u][i] ] = true;
            }
        }
    }

    int count_component()
    {
        clr(col,0);
        int ret = 0;
        for (int i = 0; i<n; i++)
            if(!col[i]) bfs(i), ret++;
        return ret;
    }



    int countPairs(vector <string> graph)
    {
        n = graph.size();
        int c, d, ans = 0;


        for (int i = 0; i<n; i++)
        {
            adj[i].clear();
            for (int j = 0; j<n; j++)
                if(graph[i][j]=='Y') adj[i].pb(j);
        }

        c = count_component();

        for (int i = 0; i<n; i++)
        {
            for (int j = i+1; j<n; j++)
            {
                for (int k = 0; k<n; k++)
                {
                    adj[k].clear();
                    if(k==i||k==j) continue;
                    for (int l = 0; l<n; l++)
                        if(graph[k][l]=='Y'&&l!=i&&l!=j) adj[k].pb(l);
                }
                d = count_component()-2;
                if(d>c) ans++;
            }
        }
        return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << "\"" << p0[i] << "\"";
    }
    cout << "}";
    cout << "]" << endl;
    Fragile2 *obj;
    int answer;
    obj = new Fragile2();
    clock_t startTime = clock();
    answer = obj->countPairs(p0);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p1 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p1;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <string> p0;
    int p1;

    // ----- test 0 -----
    disabled = false;
    p0 = {"NYNN","YNYN","NYNY","NNYN"};
    p1 = 3;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {"NYNNNN","YNYNNN","NYNNNN","NNNNYN","NNNYNY","NNNNYN"};
    p1 = 5;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {"NNN","NNN","NNN"};
    p1 = 0;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {"NYNYNNYYNN","YNNNYNYYNN","NNNNYNNNYN","YNNNYYNNNN","NYYYNNNNYN","NNNYNNNNYN","YYNNNNNNNN","YYNNNNNNYN","NNYNYYNYNY","NNNNNNNNYN"};
    p1 = 9;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 4 -----
    disabled = false;
    p0 = {"NNNYNNYNNNNNNNYYNNNY","NNNNNNNNYNNNNNNNNNNN","NNNNNNNNNNNNNNNNNNNN","YNNNNNNNNNYNNNNNNNNN","NNNNNNNYNNNNNYNNNNYN","NNNNNNNNNNNNNNNNYNNY","YNNNNNNNNNNNNYYYNYNN","NNNNYNNNNNNNNYYNNNNN","NYNNNNNNNYNNNNNNNNNN","NNNNNNNNYNNNYNNNNNYN","NNNYNNNNNNNNNNYNNNNN","NNNNNNNNNNNNNNNNNNNN","NNNNNNNNNYNNNNNNNYNN","NNNNYNYYNNNNNNNNNNNN","YNNNNNYYNNYNNNNNNNNN","YNNNNNYNNNNNNNNNYNNN","NNNNNYNNNNNNNNNYNYNN","NNNNNNYNNNNNYNNNYNNN","NNNNYNNNNYNNNNNNNNNN","YNNNNYNNNNNNNNNNNNNN"};
    p1 = 42;
    all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// Lun the dog has found an undirected graph in Shuseki Forest. The graph consisted of N vertices and some edges. The vertices of the graph were numbered 0 through N-1. Each edge connected a different pair of vertices.
//
// You are given the description of the graph in a vector <string> graph with N elements, each containing N characters. For each i and j, graph[i][j] will be 'Y' if vertex i and vertex j are connected by an edge, and 'N' otherwise. (Note that for each i, graph[i][i] will be 'N': there are no self-loops.)
//
// Lun is interested in articulation pairs in this graph. An articulation pair is an unordered pair of two different vertices whose deletion increases the number of connected components in the graph. (The deletion of a vertex also removes all edges incident with that vertex.)
//
// Return the number of the articulation pairs in Lun's graph.
//
// DEFINITION
// Class:Fragile2
// Method:countPairs
// Parameters:vector <string>
// Returns:int
// Method signature:int countPairs(vector <string> graph)
//
//
// NOTES
// -You are not given the value of N explicitly, but you can determine it as the number of elements in graph.
// -Two vertices belong to the same connected component if and only if we can reach one of them from the other by following a sequence of zero or more edges.
//
//
// CONSTRAINTS
// -graph will contain between 3 and 20 elements, inclusive.
// -Each element of graph will contain N characters, where N is the number of the elements in graph.
// -Each character of each element of graph will be either 'Y' or 'N'.
// -For each valid i and j, graph[i][j] will be equal to graph[j][i].
// -For each valid i, graph[i][i] will be 'N'.
//
//
// EXAMPLES
//
// 0)
// {"NYNN", "YNYN", "NYNY", "NNYN"}
//
// Returns: 3
//
// The graph looks as follows:
//
//
//
// The articulation pairs are (0, 2), (1, 2) and (1, 3).
// For example, here is why (0, 2) is an articulation pair:
// Currently there is one connected component.
// (It contains all four vertices.)
// If we remove the vertices 0 and 2, and all edges incident to these vertices, we will be left with two isolated vertices: 1 and 3.
// Each of these vertices now forms a different connected component, so the number of connected components increased from 1 to 2.
//
// 1)
// {"NYNNNN", "YNYNNN", "NYNNNN", "NNNNYN", "NNNYNY", "NNNNYN"}
//
// Returns: 5
//
//
//
// The articulation pairs are (0, 4), (1, 3), (1, 4), (1, 5) and (2, 4).
//
// 2)
// {"NNN", "NNN", "NNN"}
//
// Returns: 0
//
//
//
// There are no articulation pairs.
//
// 3)
// {"NYNYNNYYNN", "YNNNYNYYNN", "NNNNYNNNYN", "YNNNYYNNNN", "NYYYNNNNYN",
//  "NNNYNNNNYN", "YYNNNNNNNN", "YYNNNNNNYN", "NNYNYYNYNY", "NNNNNNNNYN"}
//
// Returns: 9
//
//
//
// 4)
// {"NNNYNNYNNNNNNNYYNNNY", "NNNNNNNNYNNNNNNNNNNN", "NNNNNNNNNNNNNNNNNNNN", "YNNNNNNNNNYNNNNNNNNN", "NNNNNNNYNNNNNYNNNNYN",
//  "NNNNNNNNNNNNNNNNYNNY", "YNNNNNNNNNNNNYYYNYNN", "NNNNYNNNNNNNNYYNNNNN", "NYNNNNNNNYNNNNNNNNNN", "NNNNNNNNYNNNYNNNNNYN",
//  "NNNYNNNNNNNNNNYNNNNN", "NNNNNNNNNNNNNNNNNNNN", "NNNNNNNNNYNNNNNNNYNN", "NNNNYNYYNNNNNNNNNNNN", "YNNNNNYYNNYNNNNNNNNN",
//  "YNNNNNYNNNNNNNNNYNNN", "NNNNNYNNNNNNNNNYNYNN", "NNNNNNYNNNNNYNNNYNNN", "NNNNYNNNNYNNNNNNNNNN", "YNNNNYNNNNNNNNNNNNNN"}
//
// Returns: 42
//
//
//
// END KAWIGIEDIT TESTING
