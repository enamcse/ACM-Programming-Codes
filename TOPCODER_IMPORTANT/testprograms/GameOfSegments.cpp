#include <bits/stdc++.h>
using namespace std;

#define clr(abc,z) memset(abc,z,sizeof(abc))

class GameOfSegments {
public:
    int nimber[1005];
	int winner(int N) {
    /// it can be thought as a Nim game which follow Sprague-Grundy theorem.
    /// because, in every step, it can be divided into two sub games of i nodes and (n-i-2) nodes.
    /// for every i in between 0<=i<=n-2.
        clr(nimber,0);
        for (int i = 0; i<=N; i++)
        {
            set<int>options;
            for (int j = 0; j<=i-2; j++)
                options.insert(nimber[j]^nimber[i-j-2]);
            nimber[i]=0;
            ///finding the minimum excluded ordinal (first non occurance).
            while(options.count(nimber[i])){
                nimber[i]++;
            }
        }
        return(nimber[N]>0?1:2);
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << p0;
	cout << "]" << endl;
	GameOfSegments *obj;
	int answer;
	obj = new GameOfSegments();
	clock_t startTime = clock();
	answer = obj->winner(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	int p0;
	int p1;

	{
	// ----- test 0 -----
	p0 = 3;
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = 4;
	p1 = 1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = 15;
	p1 = 2;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = 191;
	p1 = 2;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Rijél is a very wise teacher. He loves mathematics, especially games and geometry problems. Recently one of his students challenged him to the following game:
//
// Initially, there is a polygon with N vertices drawn in the plane. The polygon is strictly convex, i.e., each internal angle is strictly smaller than 180 degrees. The vertices of the polygon are numbered 1 through N, in clockwise order.
//
// Two players play the game on this polygon. The players take alternating turns. In each turn, the current player chooses a diagonal or a side of the polygon and draws it as a straight line segment. (A diagonal of the polygon is a line segment that connects any two non-adjacent vertices of the polygon.) The player is only allowed to choose a diagonal or a side that does not intersect any of the previously drawn segments (it must not share endpoints with any of them either). The player who cannot draw a diagonal or a side according to the above rules loses the game.
//
// You are given the int N.
//
// We assume that both players play the game optimally. Return 1 if the first player wins and 2 otherwise.
//
// DEFINITION
// Class:GameOfSegments
// Method:winner
// Parameters:int
// Returns:int
// Method signature:int winner(int N)
//
//
// CONSTRAINTS
// -N will be between 3 and 1,000, inclusive.
//
//
// EXAMPLES
//
// 0)
// 3
//
// Returns: 1
//
// This polygon has zero diagonals and three sides. The first player will always win no matter which side he picks.
//
// 1)
// 4
//
// Returns: 1
//
// This polygon has four sides and two diagonals. The first player wins the game if he takes one of the diagonals, because he will leave no choice for the second player.
//
// 2)
// 15
//
// Returns: 2
//
//
//
// 3)
// 191
//
// Returns: 2
//
//
//
// END KAWIGIEDIT TESTING

//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
