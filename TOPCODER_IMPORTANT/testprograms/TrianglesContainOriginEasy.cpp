#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;

bool flags;
class TrianglesContainOriginEasy
{
public:
    struct point
    {
        int x, y;
        point(){}
        point(int a, int b)
        {
            x = a;
            y = b;
        }
    };

int check(const point &O, const point &A, const point &B) //checks rotation
{
        int rotation = (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);
//        if(rotation == 0) return 0;
        return rotation > 0? 1 : -1;
}

    int count(vector <int> x, vector <int> y)
    {
        int n = x.size(),cnt=0;

        for (int i = 0; i<n; i++)
            for (int j = i+1; j<n; j++)
                for (int k = j+1; k<n; k++)
                {
                    point p1(x[i],y[i]);
                    point p2(x[j],y[j]);
                    point p3(x[k],y[k]);
                    point q(0,0);
                    int d1 = check(p1, p2, q);
                    int d2 = check(p2, p3, q);
                    int d3 = check(p3, p1, q);
                    if(d1==d2&&d2==d3)
                    cnt++;
                }
        flags = true;
        return cnt;
}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, int p2)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    TrianglesContainOriginEasy *obj;
    int answer;
    obj = new TrianglesContainOriginEasy();
    clock_t startTime = clock();
    answer = obj->count(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p2 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p2;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    bool disabled;
    bool tests_disabled;
    all_right = true;
    tests_disabled = false;

    vector <int> p0;
    vector <int> p1;
    int p2;

    // ----- test 0 -----
    disabled = false;
    p0 = {-1,-1,1};
    p1 = {1,-1,0};
    p2 = 1;
    all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 1 -----
    disabled = false;
    p0 = {-1,-1,1,2};
    p1 = {1,-1,2,-1};
    p2 = 2;
    all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 2 -----
    disabled = false;
    p0 = {-1,-2,3,3,2,1};
    p1 = {-2,-1,1,2,3,3};
    p2 = 8;
    all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    // ----- test 3 -----
    disabled = false;
    p0 = {1,5,10,5,-5,7,-9,-6,-3,0,8,8,1,-4,7,-3,10,9,-6};
    p1 = {5,-6,-3,4,-2,-8,-7,2,7,4,2,0,-4,-8,7,5,-5,-2,-9};
    p2 = 256;
    all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, true, p2) ) && all_right;
    tests_disabled = tests_disabled || disabled;
    // ------------------

    if (all_right)
    {
        if (tests_disabled)
        {
            cout << "You're a stud (but some test cases were disabled)!" << endl;
        }
        else
        {
            cout << "You're a stud (at least on given cases)!" << endl;
        }
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// We have chosen a finite set of points in the plane.
// You are given their coordinates in the vector <int>s x and y:
// for each valid i, there is a point with coordinates (x[i],y[i]).
//
// We are interested in triangles with the following properties:
//
// Each vertex of the triangle is one of our chosen points.
// The point (0,0) lies inside the triangle.
//
// Return the number of such triangles.
//
// Note that the constraints guarantee that there are no degenerate triangles and that the point (0,0) never lies on the boundary of a triangle.
//
//
// DEFINITION
// Class:TrianglesContainOriginEasy
// Method:count
// Parameters:vector <int>, vector <int>
// Returns:int
// Method signature:int count(vector <int> x, vector <int> y)
//
//
// CONSTRAINTS
// -x and y will contain between 3 and 50 elements, inclusive.
// -x and y will contain the same number of elements.
// -Each element of x and y will be between -1,000 and 1,000, inclusive.
// -No two points will be the same.
// -No three points will be collinear.
// -No point will be on the origin.
// -There will be no two points P and Q such that P, Q, and the origin are collinear.
//
//
// EXAMPLES
//
// 0)
// {-1,-1,1}
// {1,-1,0}
//
// Returns: 1
//
// There is exactly one possible triangle. It does contain the origin.
//
// 1)
// {-1,-1,1,2}
// {1,-1,2,-1}
//
// Returns: 2
//
// There are four possible triangles. Two of them contain the origin. One is the triangle with vertices in (-1,1), (-1,-1), and (2,-1). The other is the triangle with vertices in (-1,-1), (1,2), and (2,-1).
//
// 2)
// {-1,-2,3,3,2,1}
// {-2,-1,1,2,3,3}
//
// Returns: 8
//
//
//
// 3)
// {1,5,10,5,-5,7,-9,-6,-3,0,8,8,1,-4,7,-3,10,9,-6}
// {5,-6,-3,4,-2,-8,-7,2,7,4,2,0,-4,-8,7,5,-5,-2,-9}
//
// Returns: 256
//
//
//
// END KAWIGIEDIT TESTING
