#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);

using namespace std;


class BracketExpressions {
public:
    string str;int n;
    int rec(int pos, stack<char>s)
    {
        if(pos==n)
        {
            if(s.empty()) return 1;
            else return 0;
        }
        int res = 0;
        if(str[pos]=='(' ||str[pos]=='{' ||str[pos]=='[')
            {
                s.push(str[pos]);
                return rec(pos+1,s);
            }
        if(str[pos]=='X'){
            if(!s.empty())
            {
                char k = s.top();
                if(k=='(' ||k=='{' ||k=='['||k=='X')
                    {
                        s.pop();
                        res|=rec(pos+1,s);
                        s.push(k);
                    }
                s.push(str[pos]);
                res|=rec(pos+1,s);
                return res;
            }
            else{
                s.push(str[pos]);
                res|=rec(pos+1,s);
                 return res;
            }
        }
        if(str[pos]==')'){
            if(!s.empty()){
                if(s.top()=='('||s.top()=='X'){
                    s.pop();
                    return rec(pos+1,s);
                   }
                   else return 0;
            }
            else return 0;
           }
           if(str[pos]=='}'){
            if(!s.empty()){
                if(s.top()=='{'||s.top()=='X'){
                    s.pop();
                    return rec(pos+1,s);
                   }
                   else return 0;
            }
            else return 0;
           }
           if(str[pos]==']'){
            if(!s.empty()){
                if(s.top()=='['||s.top()=='X'){
                    s.pop();
                    return rec(pos+1,s);
                   }
                   else return 0;
            }
            else return 0;
           }
        return 0;
    }

	string ifPossible(string expression) {
		n = expression.size();
		if(n%2) return "impossible";
		str = expression;
		stack<char>s;
		if(rec(0,s)) return "possible";
		else return "impossible";
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, string p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	BracketExpressions *obj;
	string answer;
	obj = new BracketExpressions();
	clock_t startTime = clock();
	answer = obj->ifPossible(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p1 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	string p0;
	string p1;

	{
	// ----- test 0 -----
	p0 = "([]{})";
	p1 = "possible";
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	p0 = "(())[]";
	p1 = "possible";
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	p0 = "({])";
	p1 = "impossible";
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	p0 = "[]X";
	p1 = "impossible";
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 4 -----
	p0 = "([]X()[()]XX}[])X{{}}]";
	p1 = "possible";
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// We have three types of brackets: "()", "[]", and "{}".
// We are now interested in some special strings.
// A string is special if all the following conditions hold:
//
// Each character of the string is one of the six bracket characters mentioned above.
// The characters of the string can be divided into disjoint pairs such that in each pair we have an opening bracket and a closing bracket of the same type.
// For each pair, the opening bracket must occur to the left of the corresponding closing bracket.
// For each pair, the substring strictly between the opening and the closing bracket must be a special string (again, according to this definition).
//
//
// For example, the empty string is a special string: there are 0 pairs of brackets.
// The string "[]" is also a special string: there is one pair of matching brackets, they are in the proper order, and the string between them (which is the empty string) is a special string.
//
// The character 'X' (uppercase x) occurs in expression at most five times; all other characters in expression are brackets of the types mentioned above.
// We want to change expression into a special string by changing each 'X' into one of the brackets.
// (Different occurrences of 'X' may be changed into different brackets.)
// Return "possible" (quotes for clarity) if we can do that, and "impossible" otherwise.
//
// DEFINITION
// Class:BracketExpressions
// Method:ifPossible
// Parameters:string
// Returns:string
// Method signature:string ifPossible(string expression)
//
//
// CONSTRAINTS
// -expression will have between 1 and 50 characters, inclusive.
// -Each character in expression will be '(', ')', '[', ']', '{', '}' or 'X'.
// -There will be at most 5 occurences of 'X' in expression.
//
//
// EXAMPLES
//
// 0)
// "([]{})"
//
// Returns: "possible"
//
// This is already a special string. As there are no 'X's, we do not get to change anything.
//
// 1)
// "(())[]"
//
// Returns: "possible"
//
//
//
// 2)
// "({])"
//
// Returns: "impossible"
//
//
//
// 3)
// "[]X"
//
// Returns: "impossible"
//
// Regardless of bracket type you put instead of 'X', you cannot create a special string.
//
// 4)
// "([]X()[()]XX}[])X{{}}]"
//
// Returns: "possible"
//
// You can replace 'X's respectively with '{', '(', ')' and '['.
//
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
