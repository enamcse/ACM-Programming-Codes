#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;

vector<int> adj[2005];

bool col[2][2005];

class WalkingToSchool {
public:
    bool got1;
    void dfs(int x, int modu)
    {
        if(x==1) got1=1;
        if(col[modu%2][x]) return;
        col[modu%2][x]=1;
        for(int i = 0; i<adj[x].size(); i++) dfs(adj[x][i],modu+1);
    }

	string canWalkExactly(int N, vector <int> from, vector <int> to) {
        clr(col,0);
        got1=0;for (int i = 0; i<N; i++) adj[i].clear();
		for (int i = 0; i<from.size(); i++)
        {
            adj[ to[i] ].pb(from[i]);
        }

        for(int i = 0; i<adj[1].size(); i++) dfs(adj[1][i],1);



        return (col[0][1]&&col[1][1]&&got1)?"Freedom":"Chores";
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	WalkingToSchool *obj;
	string answer;
	obj = new WalkingToSchool();
	clock_t startTime = clock();
	answer = obj->canWalkExactly(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	int p0;
	vector <int> p1;
	vector <int> p2;
	string p3;

	// ----- test 0 -----
	disabled = false;
	p0 = 2;
	p1 = {0,1};
	p2 = {1,0};
	p3 = "Chores";
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = 3;
	p1 = {0,1,1,2};
	p2 = {1,0,2,0};
	p3 = "Freedom";
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = false;
	p0 = 4;
	p1 = {0,2,2,3,0};
	p2 = {2,0,3,0,1};
	p3 = "Chores";
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = false;
	p0 = 10;
	p1 = {0,0,0,0,0,1,1,2,2,2,2,3,3,5,5,5,6,6,6,7,8,9,9,9,9};
	p2 = {4,5,6,7,9,4,6,0,1,3,8,4,6,1,4,8,1,7,8,1,4,2,5,6,8};
	p3 = "Chores";
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 4 -----
	disabled = false;
	p0 = 8;
	p1 = {0,1,4,6,7,5,2,3,0};
	p2 = {1,4,6,7,5,2,3,0,7};
	p3 = "Freedom";
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 5 -----
	disabled = false;
	p0 = 2000;
	p1 = {};
	p2 = {};
	p3 = "Chores";
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Little Liz lives on a graph with N vertices, which are numbered from 0 to N-1. For each valid i, a directed edge goes from vertex from[i] to vertex to[i]. Little Liz's house is on vertex 0 and her school is on vertex 1. Little Liz wants to walk from her home to her school and back. Little Liz knows that it is often wise to arrive neither too late nor too early. For example, if she arrives late to school, she is scolded by her teacher. But if she arrives early to school, it is a waste of time because she could have awoken later. Likewise, arriving late home causes her to miss dinner, but if she arrives early, her parents will give her chores.
//
//
// For these reasons, Little Liz has defined a k-walk as a walk which uses exactly k edges. (A single edge is counted more than once if it is used more than once.) A k-route has two parts: a k-walk which starts at vertex 0 and ends at vertex 1, and a k-walk which starts at vertex 1 and ends at vertex 0. Note that the two k-walks are allowed to visit vertices 0 and 1 arbitrarily many times.
// (Liz just passes by her house / her school without going inside.)
//
//
// Please determine whether there exists a k-route for all sufficiently large k. If there exists a k-route for all sufficiently large k, return "Freedom". Otherwise, return "Chores". In other words, return "Chores" if one can find an arbitrarily large k such that there is no k-route in the given graph.
//
// DEFINITION
// Class:WalkingToSchool
// Method:canWalkExactly
// Parameters:int, vector <int>, vector <int>
// Returns:string
// Method signature:string canWalkExactly(int N, vector <int> from, vector <int> to)
//
//
// NOTES
// -The statement "there exists a k-route for all sufficiently large k" is true if and only if there is some integer x such that there exists a k-route for all k greater than x.
//
//
// CONSTRAINTS
// -N will be between 2 and 2000, inclusive.
// -M will be between 0 and 2000, inclusive.
// -from will contain exactly M elements.
// -to will contain exactly M elements.
// -Each element of from will be between 0 and N-1, inclusive.
// -Each element of to will be between 0 and N-1, inclusive.
// -The edges will be distinct.
// -No edge will connect a vertex to itself.
//
//
// EXAMPLES
//
// 0)
// 2
// {0, 1}
// {1, 0}
//
// Returns: "Chores"
//
// Little Liz's path could use any odd number of edges, but it can never use an even number of edges.
//
// 1)
// 3
// {0, 1, 1, 2}
// {1, 0, 2, 0}
//
// Returns: "Freedom"
//
//
//
// 2)
// 4
// {0, 2, 2, 3, 0}
// {2, 0, 3, 0, 1}
//
// Returns: "Chores"
//
// In this test case, there exists a k-walk from vertex 0 to vertex 1 for all sufficiently large k, but there is not a k-walk from vertex 1 to vertex 0 for all sufficiently large k.
//
// 3)
// 10
// {0, 0, 0, 0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 9, 9}
// {4, 5, 6, 7, 9, 4, 6, 0, 1, 3, 8, 4, 6, 1, 4, 8, 1, 7, 8, 1, 4, 2, 5, 6, 8}
//
// Returns: "Chores"
//
//
//
// 4)
// 8
// {0, 1, 4, 6, 7, 5, 2, 3, 0}
// {1, 4, 6, 7, 5, 2, 3, 0, 7}
//
// Returns: "Freedom"
//
//
//
// 5)
// 2000
// {}
// {}
//
// Returns: "Chores"
//
//
//
// END KAWIGIEDIT TESTING
