#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);
using namespace std;


class CandyMaking
{
public:
    double findSuitableDensity(vector <int> containerVolume, vector <int> desiredWeight)
    {
        int n = desiredWeight.size();

        double dif, ans = 1e10, cons;

        for (int  j = 0; j<n; j++)
        {
            cons = desiredWeight[j]/(double)containerVolume[j];
            dif = 0.0;
            for (int i = 0; i<n; i++) dif+=max(containerVolume[i]*cons-desiredWeight[i], desiredWeight[i]-containerVolume[i]*cons);

            ans = min(ans, dif);
        }


        return ans;

    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <int> p0, vector <int> p1, bool hasAnswer, double p2)
{
    cout << "Test " << testNum << ": [" << "{";
    for (int i = 0; int(p0.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p0[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}";
    cout << "]" << endl;
    CandyMaking *obj;
    double answer;
    obj = new CandyMaking();
    clock_t startTime = clock();
    answer = obj->findSuitableDensity(p0, p1);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p2 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == answer && fabs(p2 - answer) <= 1e-9 * max(1.0, fabs(p2));
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    vector <int> p0;
    vector <int> p1;
    double p2;

    {
        // ----- test 0 -----
        int t0[] = {5};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {1000};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        p2 = 0.0;
        all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        int t0[] = {10,10};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {1000,2000};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        p2 = 1000.0;
        all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        int t0[] = {10,20,40};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {4000,2000,1000};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        p2 = 5250.0;
        all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        int t0[] = {1234,1541,3321,1234,123,123,3414,123,12,2442,1421,1223,3232,1123,2121};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {3213,1231,232143,44312,132132,142424,123123,41341,41244,21312,232131,2312,2322,11,2223};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        p2 = 983673.2727272725;
        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        int t0[] = {30621,30620,2};
        p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
        int t1[] = {1,1,1000000};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        p2 = 999999.9999673415;
        all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
//
// Alice likes making candy.
// Recently, she promised to make candy for all her classmates.
// Alice has N classmates.
// We will number them 0 through N-1, inclusive.
//
//
//
// Each of the classmates brought Alice one container for the candy.
// Each of the classmates also has a desired total weight of their candy.
// You are given this information as two vector <int>s with N elements each: containerVolume and desiredWeight.
// For each i, the volume of the container brought by classmate i is containerVolume[i] liters, and he or she expects the candy in the container to weigh desiredWeight[i] grams.
//
//
//
// Alice has promised to fill all containers with candy completely.
// However, she only has the time to make one type of candy, with constant density.
// This means that she might be unable to meet the exact desired weights of candy.
//
//
//
// Alice now needs to choose the density of the candy she is going to make.
// In order to make everyone as happy as possible, Alice decided that she wants to minimize the sum of differences between desired and actual weights.
// In other words:
// For each classmate, we compute the positive difference between the desired and actual weight of candy they received.
// Then, we sum all those differences.
// Alice needs to choose the density of her candy so that this sum becomes as small as possible.
//
//
//
// Compute and return the minimum sum  of differences between desired and actual weights.
//
//
// DEFINITION
// Class:CandyMaking
// Method:findSuitableDensity
// Parameters:vector <int>, vector <int>
// Returns:double
// Method signature:double findSuitableDensity(vector <int> containerVolume, vector <int> desiredWeight)
//
//
// NOTES
// -Your return value must have an absolute or a relative error at most 1e-9.
//
//
// CONSTRAINTS
// -N will be between 1 and 50.
// -containerVolume and desiredWeight will each contain exactly N elements.
// -Each element of containerVolume and desiredWeight will between 1 and 1,000,000, inclusive.
//
//
// EXAMPLES
//
// 0)
// {5}
// {1000}
//
// Returns: 0.0
//
// There is one classmate. Her container has 5 liters and she expects 1000 grams of candy. Alice should choose the density of 200 grams per liter. The sum of differences between desired and actual weights is 0.
//
// 1)
// {10,10}
// {1000,2000}
//
// Returns: 1000.0
//
// There are two classmates. They have a 10-liter container each. However, one of them wants 1000 grams of candy and the other wants 2000 grams. There is no way for Alice to satisfy both of them exactly. (Note that she must always fill all containers completely.)
//
// There are multiple optimal choices for the density. For these choices, the sum of differences between desired and actual weights is 1000.
//
// 2)
// {10,20,40}
// {4000,2000,1000}
//
// Returns: 5250.0
//
//
//
// 3)
// {1234,1541,3321,1234,123,123,3414,123,12,2442,1421,1223,3232,1123,2121}
// {3213,1231,232143,44312,132132,142424,123123,41341,41244,21312,232131,2312,2322,11,2223}
//
// Returns: 983673.2727272725
//
//
//
// 4)
// {30621,30620,2}
// {1,1,1000000}
//
// Returns: 999999.9999673415
//
//
//
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
