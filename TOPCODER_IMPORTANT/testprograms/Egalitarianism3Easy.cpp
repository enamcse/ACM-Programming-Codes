#include <bits/stdc++.h>
#define _ ios_base::sync_with_stdio(0);cin.tie(0);
using namespace std;

#define inf    (1e9)

int adj[12][12];


class Egalitarianism3Easy
{
public:
    int maxCities(int n, vector <int> a, vector <int> b, vector <int> len)
    {
        int lens = a.size();

        for (int i = 0; i<n; i++)
        {
            for (int j = 0; j<n; j++)
                adj[i][j] = inf;
            adj[i][i] = 0;
        }

        for (int i = 0; i<lens; i++)
        {
            adj[ a[i] - 1 ][ b[i] - 1 ] = len[i];
            adj[ b[i] - 1 ][ a[i] - 1 ] = len[i];
        }
        int mn=inf;
        int mx=-inf;
        for (int k = 0; k<n; k++)
        {
            for (int i = 0; i<n; i++)
            {
                for (int j = 0; j<n; j++)
                    adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);
            }
        }



        for (int i = 0; i<n; i++)
        {
            for (int j = i+1; j<n; j++)
            {
                mx = max(mx, adj[i][j]);
                mn = min(mn, adj[i][j]);

            }
        }

        set<int>asol;
        int cnt, ans=1, now=0;
        for (int k = mn; k<=mx; k++)
        {

            asol.clear();
            for (int i = 0; i<n; i++)
                for (int j = i+1; j<n; j++)
                    if(adj[i][j] == k)
                    {

                        bool flag = true;
                        for (set<int>::iterator it = asol.begin(); it!=asol.end(); it++)
                        {
                            if(i==*it||j==*it) continue;
                            if(adj[i][*it]!=k)
                            {
                                flag = false;
                                break;
                            }
                            if(adj[j][*it]!=k)
                            {
                                flag = false;
                                break;
                            }
                        }
                        if(flag)
                        {
                            asol.insert(i);
                            asol.insert(j);
                        }
                    }
            ans = max(ans,asol.size();
        }
                  return ans;
    }
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, vector <int> p3, bool hasAnswer, int p4)
{
    cout << "Test " << testNum << ": [" << p0 << "," << "{";
    for (int i = 0; int(p1.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p1[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p2.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p2[i];
    }
    cout << "}" << "," << "{";
    for (int i = 0; int(p3.size()) > i; ++i)
    {
        if (i > 0)
        {
            cout << ",";
        }
        cout << p3[i];
    }
    cout << "}";
    cout << "]" << endl;
    Egalitarianism3Easy *obj;
    int answer;
    obj = new Egalitarianism3Easy();
    clock_t startTime = clock();
    answer = obj->maxCities(p0, p1, p2, p3);
    clock_t endTime = clock();
    delete obj;
    bool res;
    res = true;
    cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
    if (hasAnswer)
    {
        cout << "Desired answer:" << endl;
        cout << "\t" << p4 << endl;
    }
    cout << "Your answer:" << endl;
    cout << "\t" << answer << endl;
    if (hasAnswer)
    {
        res = answer == p4;
    }
    if (!res)
    {
        cout << "DOESN'T MATCH!!!!" << endl;
    }
    else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2)
    {
        cout << "FAIL the timeout" << endl;
        res = false;
    }
    else if (hasAnswer)
    {
        cout << "Match :-)" << endl;
    }
    else
    {
        cout << "OK, but is it right?" << endl;
    }
    cout << "" << endl;
    return res;
}
int main()
{
    bool all_right;
    all_right = true;

    int p0;
    vector <int> p1;
    vector <int> p2;
    vector <int> p3;
    int p4;

    {
        // ----- test 0 -----
        p0 = 4;
        int t1[] = {1,1,1};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {2,3,4};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {1,1,1};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 3;
        all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 1 -----
        p0 = 6;
        int t1[] = {1,2,3,2,3};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {2,3,4,5,6};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {2,1,3,2,3};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 3;
        all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 2 -----
        p0 = 10;
        int t1[] = {1,1,1,1,1,1,1,1,1};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {2,3,4,5,6,7,8,9,10};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {1000,1000,1000,1000,1000,1000,1000,1000,1000};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 9;
        all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 3 -----
        p0 = 2;
        int t1[] = {1};
        p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
        int t2[] = {2};
        p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
        int t3[] = {3};
        p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
        p4 = 2;
        all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    {
        // ----- test 4 -----
        p0 = 1;
        p1.clear() /*{}*/;
        p2.clear() /*{}*/;
        p3.clear() /*{}*/;
        p4 = 1;
        all_right = KawigiEdit_RunTest(4, p0, p1, p2, p3, true, p4) && all_right;
        // ------------------
    }

    if (all_right)
    {
        cout << "You're a stud (at least on the example cases)!" << endl;
    }
    else
    {
        cout << "Some of the test cases had errors." << endl;
    }
    return 0;
}
// PROBLEM STATEMENT
// In Treeland there are n cities, numbered 1 through n.
// The cities are linked by n-1 bidirectional roads.
// Each road connects a pair of cities.
// The roads are built in such a way that each city is reachable from each other city by roads.
// (In other words, the topology of the road network is a tree.)
//
//
// You are given the int n and three vector <int>s that describe the road network: a, b, and len.
// For each i between 0 and n-2, inclusive, there is a road of length len[i] that connects the cities a[i] and b[i].
//
//
// The distance between two cities is the sum of lengths of roads on the sequence of roads that connects them. (Note that this sequence of roads is always unique.)
//
//
// You want to select k cities in such a way that all pairwise distances between the selected cities are the same.
// In other words, there must be a distance d such that the distance between every two selected cities is d.
// Return the largest possible value of k for which this is possible.
//
// DEFINITION
// Class:Egalitarianism3Easy
// Method:maxCities
// Parameters:int, vector <int>, vector <int>, vector <int>
// Returns:int
// Method signature:int maxCities(int n, vector <int> a, vector <int> b, vector <int> len)
//
//
// CONSTRAINTS
// -n will be between 1 and 10, inclusive.
// -a will contain exactly n-1 elements.
// -b will contain exactly n-1 elements.
// -len will contain exactly n-1 elements.
// -Each element in a will be between 1 and n, inclusive.
// -Each element in b will be between 1 and n, inclusive.
// -Each element in len will be between 1 and 1,000, inclusive.
// -The graph described by a and b will be a tree.
//
//
// EXAMPLES
//
// 0)
// 4
// {1,1,1}
// {2,3,4}
// {1,1,1}
//
// Returns: 3
//
// There are 4 cities and 3 roads, each of length 1.
// The roads connect the following pairs of cities: (1,2), (1,3), and (1,4).
// The optimal answer is k=3.
// We can select three cities in the required way: we select the cities {2, 3, 4}.
// The distance between any two of these cities is 2.
//
// 1)
// 6
// {1,2,3,2,3}
// {2,3,4,5,6}
// {2,1,3,2,3}
//
// Returns: 3
//
// Again, the largest possible k is 3.
// There are two ways to select three equidistant cities: {1, 4, 6} and {4, 5, 6}.
// (In both cases the common distance is 3.)
//
// 2)
// 10
// {1,1,1,1,1,1,1,1,1}
// {2,3,4,5,6,7,8,9,10}
// {1000,1000,1000,1000,1000,1000,1000,1000,1000}
//
// Returns: 9
//
//
//
// 3)
// 2
// {1}
// {2}
// {3}
//
// Returns: 2
//
//
//
// 4)
// 1
// {}
// {}
// {}
//
// Returns: 1
//
// Note that n can be 1.
//
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
