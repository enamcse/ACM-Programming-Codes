#include <bits/stdc++.h>

#define all(a)           a.begin(),a.end()
#define chng(a,b)       a^=b^=a^=b;
#define clr(y,z)        memset(y,z,sizeof(y))
#define cntbit(mask)     __builtin_popcount(mask)
#define CROSS(a,b,c,d) ((b.x-a.x)*(d.y-c.y)-(d.x-c.x)*(b.y-a.y))
#define fr(i,a,b)       for(i=a;i<=b;i++)
#define inf             (1e9)
#define mod             1000000007
#define ll              long long
#define oo              (1<<30)
#define pb              push_back
#define PI              3.141592653589793
#define pi              (2*acos(0))
#define pp              pop_back
#define rev(a)          reverse(all(a));
#define SIZE(s)         ((int)s.size())
#define saja(a)         sort(all(a))
#define sqr(a)          ((a)*(a))
#define SZ              50005
#define V(a)            vector<(a)>

using namespace std;


class JanuszInTheCasino {
public:

    int M;
    map<pair<ll,int>,double>mpp;
    double rec(ll n, int k)
    {
        if (n==0) return 0.0;
        if (k==0) return 1.0;

        if(mpp.find({n,k})!=mpp.end()) return mpp[{n,k}];
        ll m, r;
        m = n%M;
        r = n/M;
        double ret;
        double now = (m*1.0)/(M*1.0);

        ret = rec(n-r, k-1)*(1-now);
        ret += rec(n-r-1,k-1)*now;

        mpp[{n,k}] = ret;
        return ret;
    }

	double findProbability(long long n, int m, int k) {
		M = m;

		mpp.clear();
		double ret = rec(n,k);
		return ret;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, long long p0, int p1, int p2, bool hasAnswer, double p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	JanuszInTheCasino *obj;
	double answer;
	obj = new JanuszInTheCasino();
	clock_t startTime = clock();
	answer = obj->findProbability(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == answer && fabs(p3 - answer) <= 1e-9 * max(1.0, fabs(p3));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;

	long long p0;
	int p1;
	int p2;
	double p3;

	// ----- test 0 -----
	disabled = false;
	p0 = 3ll;
	p1 = 2;
	p2 = 2;
	p3 = 0.75;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 1 -----
	disabled = false;
	p0 = 1ll;
	p1 = 3;
	p2 = 3;
	p3 = 0.2962962962962962;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 2 -----
	disabled = false;
	p0 = 4ll;
	p1 = 3;
	p2 = 2;
	p3 = 1.0;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 3 -----
	disabled = false;
	p0 = 5ll;
	p1 = 4;
	p2 = 5;
	p3 = 0.87109375;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	// ----- test 4 -----
	disabled = false;
	p0 = 1000000000000ll;
	p1 = 2;
	p2 = 40;
	p3 = 0.9094947017729282;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, true, p3) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------

	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// Janusz is in a casino with some friends.
// Their group consists of n people.
// They are all going to play a game.
//
// The game is played on a plan that is divided into m fields.
// At the beginning of the game, each player gets their own unique token.
// The game then consists of k rounds.
// Each round looks as follows:
//
// Each player places their token onto one of the fields.
// One of the fields is chosen uniformly at random.
// The tokens in the chosen field are removed from the game. The players who placed those tokens are out of the game.
//
// The players who are still in the game after the last round win the game.
//
// Our group of players wants to maximize the probability that at least one of them wins the game.
// You are given the long long n and the ints m and k.
// Compute and return the probability that there will be at least one winner if they play the game optimally.
//
//
// DEFINITION
// Class:JanuszInTheCasino
// Method:findProbability
// Parameters:long long, int, int
// Returns:double
// Method signature:double findProbability(long long n, int m, int k)
//
//
// NOTES
// -The return value must have an absolute error at most 1e-3.
//
//
// CONSTRAINTS
// -n will be between 1 and 10^12, inclusive.
// -m and k will be between 1 and 50, inclusive.
//
//
// EXAMPLES
//
// 0)
// 3
// 2
// 2
//
// Returns: 0.75
//
// There are 3 players, 2 fields on the plan, and 2 rounds of the game.
// In the first round the players should place one token onto the first field and two tokens onto the second field.
//
// With probability 0.5 the first field is chosen.
// If that happens, there will be two players in the second round.
// Each of them will choose a different field and thus one of them will certainly win the game.
//
// With probability 0.5 the second field is chosen in the first round.
// If that happens, there will only be a single player in the second round.
// The probability that this player survives the second round is 0.5.
//
// Hence, the answer is 0.5*1 + 0.5*0.5 = 0.75.
//
//
// 1)
// 1
// 3
// 3
//
// Returns: 0.2962962962962962
//
// There is only one player: Janusz.
// He will survive each round with probability 2/3.
// Hence, the probability that he will win the entire game is (2/3)^3.
//
// 2)
// 4
// 3
// 2
//
// Returns: 1.0
//
// One optimal strategy for the first round is to put two tokens onto one field and one token onto each of the other two fields.
// Even if we lose the two tokens, we will still have two players in the second round and we can make sure that at least one of them will win the game.
//
// 3)
// 5
// 4
// 5
//
// Returns: 0.87109375
//
//
//
// 4)
// 1000000000000
// 2
// 40
//
// Returns: 0.9094947017729282
//
//
//
// END KAWIGIEDIT TESTING
